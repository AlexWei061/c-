#include<iostream>
#include<string.h>
using namespace std;

/*
    [题目描述]
    棋盘上A点有一个过河卒，需要走到目标B点。卒行走的规则：可以向下、或者向右。同时在棋盘上C点有一个对方的马，该马所在的点和所有跳跃一步可达
    的点称为对方马的控制点。因此称之为“马拦过河卒”。马的行走规则是：走'日'字也就是走边长为1和2的矩形的对角线。
    棋盘用坐标表示，A点(0, 0)、B(n, m)(n, m为不超过2020的整数)，同样马的位置坐标是需要给出的。
    现在要求你计算出卒从A点能够到达B点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

    [输入格式]
    一行四个数据，分别表示B点坐标和马的坐标。

    [输出格式]
    一个数据，表示所有的路径条数。

    [输入样例]
    6 6 3 3

    [输出样例]
    6
*/

int hx = 0;                                                //创建马坐标的x轴
int hy = 0;                                                //创建马坐标的y轴
int n = 0;                                                 //B点x坐标(n <= 2020)
int m = 0;                                                 //B点y坐标(m <= 2020)
int way[2022][2022];                                       //做搜索标记
const int spx[4] = {1,  0, -1, 0};                         //创建卒可以走到的点的x坐标相对卒x坐标的增量
const int spx[4] = {0, -1,  0, 1};                         //创建卒可以走到的点的y坐标相对卒y坐标的增量                   
const int hpx[8] = {-2, -2, -1, 1, 2,  2,  1, -1};         //创建马可以走到的点的x坐标相对马x坐标的增量
const int hpy[8] = {-1,  1,  2, 2, 1, -1, -2, -2};         //创建马可以走到的点的y坐标相对马y坐标的增量

//深度优先 求路线的个数
int num_of_ways(){

}

int main(){
    freopen("soldier.in","r",stdin);
    freopen("soldier.out","w",stdout);
    scanf("%d%d%d%d",&n,&m,&hx,&hy);                       //输入n，m，hx，hy
    memset(way,0,sizeof(way));                             //初始化way(都为0)
    way[hx][hy] = 1;                                       //把马的位置设为1
    //把马可以走到的位置设为1
    for (int i = 0; i < 8; i++){
        int x = hx + hpx[i];                               //马可以走到位置的x坐标
        int y = hy + hpy[i];                               //马可以走到位置的y坐标
        if (x < 0 || x > n || y < 0 || y > m){             //判断是否越界
            continue;                                      //下一个点
        }
        way[x][y] = 1;                                     //标记马可以走到的点
    }
    return 0;
}